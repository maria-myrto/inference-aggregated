#==============================================================================
# returns gradient of aggregate LV (KF2) for use in the ode solver
# inputs
# y: matrix of the elements of the system
# t: time points
# c: matrix of parameters
#==============================================================================

import numpy as np
#h11 = y[7]
#h12 = y[8]
#h21 = y[9]
#h22 = y[10]
#q11 = y[11]
#q12 = y[12]
#q22 = y[13]
def LV2_jac(y,t,c):
        #print 'jac2'
        return np.array([[c[0]-c[1]*y[1],-c[1]*y[0],0,0,0,0,0,0,0,0,0,0,0,0], [c[1]*y[1],c[1]*y[0]-c[2],0,0,0,0,0,0,0,0,0,0,0,0],[-2*y[3]*c[1]+c[1]*y[1]+c[0],-2*y[2]*c[1]+c[1]*y[0],2*(c[0]-c[1]*y[1]),-2*c[1]*y[0],0,0,0,0,0,0,0,0,0,0],[c[1]*(y[3]-y[4]-y[1]),c[1]*(-y[3]+y[2]-y[0]),c[1]*y[1],c[1]*y[0]-c[2]+c[0]-c[1]*y[1],-c[1]*y[0],0,0,0,0,0,0,0,0,0],[2*y[4]*c[1]+c[1]*y[1],2*y[3]*c[1]+c[1]*y[0]+c[2],0,2*c[1]*y[1],2*(c[1]*y[0]-c[2]),0,0,0,0,0,0,0,0,0],[1.0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1.0,0,0,0,0,0,0,0,0,0,0,0,0],[-c[1]*y[8],-c[1]*y[7],1.0,0,0,0,0,(c[0]-c[1]*y[1]),-c[1]*y[0],0,0,0,0,0],[y[8]*c[1],c[1],0,1.0,0,0,0,c[1]*y[1],c[1]*y[0]-c[2],0,0,0,0,0],[-y[10]*c[1],-c[1]*y[9],0,1.0,0,0,0,0,0,c[0]-c[1]*y[1],-1.0,0,0,0],[y[10]*c[1],y[9]*c[1],0,0,1.0,0,0,0,0,c[1]*y[1],c[1]*y[0]-c[2],0,0,0],[0,0,0,0,0,0,0,2.0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1.0,1.0,0,0,0,0]
,[0,0,0,0,0,0,0,0,0,0,2.0,0,0,0]])
